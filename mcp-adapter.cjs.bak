/**
 * @fileoverview Microsoft 365 MCP Adapter
 *
 * This adapter implements the Model Context Protocol (MCP) to enable Claude
 * to access Microsoft 365 data (mail, calendar, files) through the MCP server.
 * 
 * It follows the official MCP specification at https://modelcontextprotocol.io/
 * 
 * This adapter uses a proxy approach to communicate with backend modules without
 * directly importing them, providing true isolation between the MCP protocol
 * handling and the backend implementation.
 */

const readline = require('readline');
const fs = require('fs');
const path = require('path');
const os = require('os');

// HTTP client for API communication
const http = require('http');
const https = require('https');
const { URLSearchParams } = require('url');
const Joi = require('joi'); // For parameter validation

// Import monitoring and error services
const monitoringService = require('./src/core/monitoring-service.cjs');
const errorService = require('./src/core/error-service.cjs');

// API configuration
const API_HOST = process.env.API_HOST || 'localhost';
const API_PORT = process.env.API_PORT || 3000;
const API_BASE_PATH = process.env.API_BASE_PATH || '/api';
const API_TIMEOUT = process.env.API_TIMEOUT || 30000; // 30 seconds

// Configuration
const LOG_DIR = process.env.MCP_LOG_DIR || path.join(os.tmpdir(), 'mcp-logs');
const LOG_FILE = process.env.MCP_LOG_PATH || path.join(LOG_DIR, 'mcp-adapter.log');

// Create log directory if it doesn't exist
try {
    if (!fs.existsSync(LOG_DIR)) {
        fs.mkdirSync(LOG_DIR, { recursive: true });
    }
} catch (err) {
    // Use process.stderr directly to avoid circular dependencies with logging functions
    process.stderr.write(`[ERROR] Failed to create log directory: ${err.message}\n`);
}

// Monkey-patch console methods to prevent JSON-RPC stream pollution
// Store original console methods
const originalConsole = {
    log: console.log,
    debug: console.debug,
    info: console.info,
    warn: console.warn,
    error: console.error
};

// Helper: Write to the appropriate log file based on level
function writeToLogFile(level, ...args) {
    try {
        const timestamp = new Date().toISOString();
        const prefix = `[MCP ADAPTER ${level.toUpperCase()}]`;
        const formattedArgs = args.map(arg => {
            if (typeof arg === 'object') {
                try {
                    return JSON.stringify(arg);
                } catch (e) {
                    return `[Object: ${Object.prototype.toString.call(arg)}]`;
                }
            }
            return String(arg);
        }).join(' ');
        
        // CRITICAL: NEVER write to stdout in an MCP adapter - it corrupts the JSON-RPC stream
        // Only write to stderr or use monitoring service
        
        // In Claude Desktop environment, we can't write to files, so use stderr and monitoring
        process.stderr.write(`${prefix} ${formattedArgs}\n`);
        
        // Try to use monitoring service asynchronously
        try {
            setImmediate(() => {
                if (level === 'error') {
                    monitoringService.error(`${prefix} ${formattedArgs}`, {});
                } else if (level === 'warn') {
                    monitoringService.warn(`${prefix} ${formattedArgs}`, {});
                } else if (level === 'debug') {
                    monitoringService.debug(`${prefix} ${formattedArgs}`, {});
                } else {
                    monitoringService.info(`${prefix} ${formattedArgs}`, {});
                }
            });
        } catch (monitoringErr) {
            // Silently ignore monitoring errors - we already logged to stderr
        }
    } catch (err) {
        // Last resort fallback - write directly to stderr
        process.stderr.write(`[ERROR LOGGING] Failed to log message: ${err.message}\n`);
    }
}

// Replace console methods with our safe versions that NEVER write to stdout
console.log = (...args) => {
    // NEVER use originalConsole.log as it writes to stdout
    writeToLogFile('info', ...args);
};
console.debug = (...args) => writeToLogFile('debug', ...args);
console.info = (...args) => writeToLogFile('info', ...args);
console.warn = (...args) => writeToLogFile('warn', ...args);
console.error = (...args) => writeToLogFile('error', ...args);

// Adapter state
let adapterState = {
    initialized: false,
    lastActivity: 0,
    backendAvailable: false
};

// Helper: Initialize the adapter and check backend availability
let healthCheckInterval = null; // Keep track of the interval timer
const HEALTH_CHECK_INTERVAL_MS = 60 * 1000; // Check every 60 seconds

/**
 * Call the API server
 * @param {string} method - HTTP method (GET, POST, PUT, PATCH, DELETE)
 * @param {string} path - API path (e.g., '/v1/mail')
 * @param {object} data - Request data for POST requests
 * @returns {Promise<object>} - API response
 */
// TODO: [callApi] Implement circuit breaker pattern (e.g., using 'opossum') (HIGH)
// TODO: [callApi] Refine retry logic (e.g., exponential backoff, specific status codes) (MEDIUM)
// TODO: [callApi] Support PATCH/PUT; add retry + circuit breaker (HIGH) - Partially Implemented (PUT/PATCH support + Basic Retry added)
async function callApi(method, path, data = null) {
    const MAX_RETRIES = 3;
    const RETRY_DELAY_MS = 100;
    let lastError = null;

    for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
        try {
            return await new Promise((resolve, reject) => {
                const options = {
                    hostname: API_HOST,
                    port: API_PORT,
                    path: `${API_BASE_PATH}${path}`,
                    method: method,
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json',
                        'X-MCP-Internal-Call': 'true'
                    },
                    timeout: API_TIMEOUT
                };

                const requestBody = data ? JSON.stringify(data) : null;

                if (requestBody && ['POST', 'PUT', 'PATCH'].includes(method.toUpperCase())) {
                    options.headers['Content-Length'] = Buffer.byteLength(requestBody);
                }

                const req = http.request(options, (res) => {
                    let responseData = '';
                    res.on('data', (chunk) => { responseData += chunk; });
                    res.on('end', () => {
                        try {
                            if (!responseData) {
                                if (res.statusCode >= 200 && res.statusCode < 300) {
                                    return resolve({});
                                } else {
                                    // Treat 5xx errors as potentially retryable
                                    const err = new Error(`API error: ${res.statusCode} with empty response`);
                                    if (res.statusCode >= 500) err.isRetryable = true;
                                    return reject(err);
                                }
                            }

                            const parsedData = JSON.parse(responseData);
                            if (res.statusCode >= 400) {
                                const err = new Error(`API error: ${res.statusCode} ${parsedData.error || responseData}`);
                                // Treat 5xx errors as potentially retryable
                                if (res.statusCode >= 500) err.isRetryable = true;
                                reject(err);
                            } else {
                                resolve(parsedData);
                            }
                        } catch (parseError) {
                            reject(new Error(`Failed to parse API response: ${parseError.message}. Raw: ${responseData.slice(0, 100)}...`));
                        }
                    });
                });

                req.on('error', (error) => {
                    // Network errors are retryable
                    error.isRetryable = true;
                    reject(new Error(`API request network error: ${error.message}`));
                });

                req.on('timeout', () => {
                    req.destroy();
                    const timeoutError = new Error(`API request timed out after ${API_TIMEOUT}ms`);
                    timeoutError.isRetryable = true; // Timeouts are retryable
                    reject(timeoutError);
                });

                if (requestBody && ['POST', 'PUT', 'PATCH'].includes(method.toUpperCase())) {
                    req.write(requestBody);
                }
                req.end();
            });
        } catch (error) {
            lastError = error;
            if (error.isRetryable && attempt < MAX_RETRIES) {
                logDebug(`[callApi] Attempt ${attempt} failed (${error.message}), retrying in ${RETRY_DELAY_MS * attempt}ms...`);
                await new Promise(resolve => setTimeout(resolve, RETRY_DELAY_MS * attempt)); // Simple increasing delay
            } else {
                logDebug(`[callApi] Failed after ${attempt} attempts: ${error.message}`);
                throw lastError; // Throw the last encountered error
            }
        }
    }
    // This line should technically not be reached if MAX_RETRIES >= 1
    throw lastError || new Error('callApi failed after all retries.');
}

// Helper: log debug messages safely (never to stdout)
function logDebug(message, ...args) {
    // CRITICAL: NEVER write to stdout in an MCP adapter - it corrupts the JSON-RPC stream
    try {
        // Format args for better readability
        const context = args.length > 0 ? { args: args.map(arg => {
            if (typeof arg === 'object') {
                try {
                    return JSON.stringify(arg);
                } catch (e) {
                    return `[Object: ${Object.prototype.toString.call(arg)}]`;
                }
            }
            return String(arg);
        })} : {};
        
        // Only write directly to stderr, never to stdout
        process.stderr.write(`[DEBUG] ${message}\n`);
        
        // Attempt to log to monitoring service, but catch any errors
        try {
            // Use setImmediate to ensure this doesn't block the main thread
            // and wrap in try/catch to prevent any errors from bubbling up
            setImmediate(() => {
                try {
                    monitoringService.debug(`[MCP ADAPTER] ${message}`, context);
                } catch (innerErr) {
                    // Prevent any errors from escaping setImmediate
                    process.stderr.write(`[MONITORING ERROR] ${innerErr.message}\n`);
                }
            });
        } catch (monitoringErr) {
            // Silently ignore monitoring errors - we already logged to stderr
        }
    } catch (err) {
        // Last resort fallback - write directly to stderr
        process.stderr.write(`[ERROR LOGGING] Failed to log debug message: ${err.message}\n`);
    }
}

// Helper: log to separate file only (never to stdout)
// Uses MonitoringService for centralized logging
function logToFile(prefix, method, data) {
    try {
        // Format data for better readability
        const context = {
            prefix,
            method,
            data: data ? (typeof data === 'object' ? data : { value: data }) : null
        };
        
        // CRITICAL: Use setImmediate to ensure this doesn't block the main thread
        // and wrap in try/catch to prevent any errors from bubbling up
        setImmediate(() => {
            try {
                // Send to monitoring service as info level (can be filtered in logs)
                monitoringService.info(`[MCP ADAPTER] ${prefix} ${method}`, context);
            } catch (innerErr) {
                // Prevent any errors from escaping setImmediate
                process.stderr.write(`[MONITORING ERROR] ${innerErr.message}\n`);
                
                // Try to create an error record using the error service
                try {
                    errorService.createError(
                        errorService.CATEGORIES.SYSTEM,
                        `Failed to log MCP adapter message: ${innerErr.message}`,
                        errorService.SEVERITIES.WARNING,
                        { prefix, method }
                    );
                } catch (e) {
                    // If even that fails, last resort is stderr
                    process.stderr.write(`[CRITICAL] Error service failure: ${e.message}\n`);
                }
            }
        });
    } catch (err) {
        // Last resort fallback - write directly to stderr
        process.stderr.write(`[ERROR LOGGING] Failed to log to monitoring service: ${err.message}\n`);
    }
}

// Helper: send JSON-RPC response
function sendResponse(id, result, error) {
    // CRITICAL: This function must ONLY write valid JSON-RPC to stdout
    // All logging must go to stderr or monitoring service
    
    // Create a valid JSON-RPC 2.0 response
    const msg = { jsonrpc: '2.0', id };
    
    // Sanitize and validate the response
    if (error) {
        // Ensure error has required fields according to JSON-RPC 2.0 spec
        if (typeof error === 'object') {
            // Ensure error code is present and is a number
            if (!('code' in error) || typeof error.code !== 'number') {
                error.code = -32603; // Internal error
            }
            
            // Ensure error message is present and is a string
            if (!('message' in error) || typeof error.message !== 'string') {
                error.message = 'Unknown error';
            }
            
            // Sanitize large error data if present
            if (error.data) {
                try {
                    const errorDataStr = JSON.stringify(error.data);
                    if (errorDataStr.length > 1000) {
                        // Truncate large error data
                        error.data = {
                            truncated: true,
                            message: 'Error data too large, truncated',
                            preview: errorDataStr.substring(0, 500) + '...'
                        };
                    }
                } catch (dataErr) {
                    // If error data can't be serialized, replace it
                    error.data = {
                        error: 'Error data could not be serialized',
                        message: dataErr.message
                    };
                }
            }
        } else {
            // Convert non-object errors to standard format
            error = {
                code: -32603,
                message: String(error)
            };
        }
        
        msg.error = error;
        
        // Log error to monitoring service (but not to stdout)
        setImmediate(() => {
            try {
                errorService.createError(
                    errorService.CATEGORIES.API,
                    `JSON-RPC error response: ${error.message}`,
                    errorService.SEVERITIES.WARNING,
                    { id, error }
                );
            } catch (e) {
                // Silently ignore - we'll still send the response
                process.stderr.write(`[ERROR SERVICE] Failed to log error: ${e.message}\n`);
            }
        });
    } else if (result !== undefined) {
        // Sanitize large result payloads
        try {
            const resultStr = JSON.stringify(result);
            // Check if result is too large (over 10MB)
            if (resultStr.length > 10 * 1024 * 1024) {
                // Log the issue but don't modify the result
                // This avoids breaking functionality while still providing a warning
                process.stderr.write(`[WARNING] Large result payload detected: ${resultStr.length} bytes\n`);
                
                // Log asynchronously to avoid blocking
                setImmediate(() => {
                    try {
                        monitoringService.warn('[MCP Adapter] Large result payload', { size: resultStr.length, id });
                    } catch (e) {
                        // Silently ignore monitoring errors
                    }
                });
            }
            msg.result = result;
        } catch (err) {
            // Handle case where result can't be serialized
            process.stderr.write(`[ERROR] Error serializing result: ${err.message}\n`);
            
            // Create proper error response
            msg.error = {
                code: -32603,
                message: 'Internal error: Could not serialize result',
                data: { error: err.message }
            };
            delete msg.result; // Ensure we don't have both result and error
        }
    } else {
        // Ensure result is always present when no error
        msg.result = null;
    }
    
    // Send the response as a single line of JSON
    try {
        const responseStr = JSON.stringify(msg);
        
        // CRITICAL: This is the ONLY place in the entire adapter that should write to stdout
        process.stdout.write(responseStr + '\n');
        
        // Log the response metadata (but not to stdout)
        // Use setImmediate to ensure this doesn't block the main thread
        setImmediate(() => {
            try {
                logToFile('Response:', id ? `id=${id}` : 'notification', {
                    size: responseStr.length,
                    hasError: !!error
                });
            } catch (e) {
                // Silently ignore logging errors
            }
        });
    } catch (err) {
        // Last resort error handling - write directly to stderr
        process.stderr.write(`[ERROR] Failed to stringify JSON-RPC response: ${err.message}\n`);
        
        // Try to send a basic error response
        try {
            const fallbackResponse = JSON.stringify({
                jsonrpc: '2.0',
                id,
                error: {
                    code: -32603,
                    message: 'Internal error: Failed to stringify response'
                }
            });
            process.stdout.write(fallbackResponse + '\n');
        } catch (e) {
            // If even that fails, we can't do anything more
            process.stderr.write(`[CRITICAL] Cannot send any response: ${e.message}\n`);
        }
    }
}

// Helper: Initialize the adapter and check backend availability
async function initializeAdapter() {
    if (adapterState.initialized) {
        return adapterState.backendAvailable;
    }

    try {
        // Check if backend API is available by calling the health endpoint
        const healthResponse = await callApi('GET', '/health');

        if (!healthResponse || healthResponse.status !== 'ok') {
            logDebug('[MCP Adapter] Error: Backend API server not available');
            adapterState.backendAvailable = false;
        } else {
            logDebug('[MCP Adapter] Successfully connected to backend API server');
            adapterState.backendAvailable = true;
            adapterState.initialized = true;

            // Start periodic health checks only if initial check was successful
            if (!healthCheckInterval) {
                healthCheckInterval = setInterval(async () => {
                    try {
                        const healthResponse = await callApi('GET', '/health');
                        if (healthResponse && healthResponse.status === 'ok') {
                            if (!adapterState.backendAvailable) {
                                logDebug('[MCP Adapter] Backend API server became available again.');
                                adapterState.backendAvailable = true;
                                // TODO: Reset consecutive failure count here
                            }
                        } else {
                            throw new Error('Backend health check failed or returned invalid status');
                        }
                    } catch (error) {
                        if (adapterState.backendAvailable) {
                            logDebug(`[MCP Adapter] Periodic health check failed: ${error.message}. Marking backend as unavailable.`);
                            adapterState.backendAvailable = false;
                            // TODO: Increment consecutive failure count here
                            // TODO: Implement fail-fast: if consecutive failures > threshold, clearInterval(healthCheckInterval) and log permanent failure.
                        }
                        // else: It was already unavailable, do nothing extra
                    }
                }, HEALTH_CHECK_INTERVAL_MS);

                // TODO: Ensure healthCheckInterval is cleared on adapter shutdown/process exit.
            }
        }
        return adapterState.backendAvailable;
    } catch (error) {
        logDebug(`[MCP Adapter] Initialization error: ${error.message}`);
        adapterState.initialized = true;
        adapterState.backendAvailable = false;
        return false;
    }
}

/**
 * Check if the backend API is available and if tools/modules are loaded.
 * Calls the `/v1/tools` endpoint.
 */
async function checkModuleAccess() {
    try {
        if (!adapterState.initialized) {
            await initializeAdapter();
        }

        if (!adapterState.backendAvailable) {
            logDebug('[MCP Adapter] checkModuleAccess: Backend API server is not available (cached state).');
            return false;
        }

        // Check if tools are accessible via the API
        logDebug('[MCP Adapter] checkModuleAccess: Checking /v1/tools endpoint...');
        const toolsResponse = await callApi('GET', '/v1/tools');

        // Check for a successful response and a non-empty tools array
        if (toolsResponse && Array.isArray(toolsResponse.tools) && toolsResponse.tools.length > 0) {
            logDebug(`[MCP Adapter] checkModuleAccess: Success - ${toolsResponse.tools.length} tools reported by API.`);
            return true;
        } else {
            logDebug('[MCP Adapter] checkModuleAccess: Failed - API did not return a valid tools list.', toolsResponse);
            return false;
        }
    } catch (error) {
        logDebug(`[MCP Adapter] checkModuleAccess: Error checking /v1/tools - ${error.message}`);
        return false;
    }
}

// Helper: Execute a module method with error handling via API
// @param {string} moduleName - Name of the module
// @param {string} methodName - Name of the method
// @param {object} params - Parameters for the method
// @param {string} [apiPath] - Full API path from tool definition (if available)
// @param {string} [apiMethod] - HTTP method from tool definition (if available)
// @returns {Promise<object>} - API response
async function executeModuleMethod(moduleName, methodName, params = {}, apiPath = null, apiMethod = null) {
    try {
        // Make sure adapter is initialized
        if (!adapterState.initialized) {
            await initializeAdapter();
        }

        // Update last activity timestamp
        adapterState.lastActivity = Date.now();

        // --- Parameter Transformation ---
        // Instead of validating parameters, we'll transform them as needed
        // to match the format expected by the backend API
        
        // Log the parameters being processed
        logDebug(`[MCP Adapter] Processing parameters for ${moduleName}.${methodName}:`, params);
        
        // Transform parameters based on the module and method
        // This ensures compatibility with the backend API expectations
        let transformedParams = { ...params }; // Start with a copy of the original params
        // Initialize API variables
        let apiData = null;
        
        // Use provided apiPath and apiMethod if available, otherwise construct them
        if (!apiPath || !apiMethod) {
            // Determine API path and method based on module.method if not provided
            const moduleMethod = `${moduleName}.${methodName}`;
            apiMethod = apiMethod || 'GET'; // Default to GET if not provided
            
            // Log the module method being executed for debugging
            logDebug(`[MCP Adapter] Executing module method: ${moduleMethod} with params:`, transformedParams);
        
        // Helper function to transform attendees from string or array to proper format
        const transformAttendees = (attendees) => {
            if (!attendees) return undefined;
            
            // If attendees is a string (comma-separated), convert to array
            if (typeof attendees === 'string') {
                return attendees.split(',').map(email => email.trim());
            }
            
            // If already an array, return as is
            return attendees;
        };
        
        // Helper function to transform date/time to proper format
        const transformDateTime = (dateTime, timeZone = 'UTC') => {
            if (!dateTime) return undefined;
            
            // If already an object with dateTime, return as is
            if (typeof dateTime === 'object' && dateTime.dateTime) {
                return dateTime;
            }
            
            // If a string, convert to object format
            if (typeof dateTime === 'string') {
                return {
                    dateTime: dateTime,
                    timeZone: timeZone
                };
            }
            
            return dateTime;
        };
        
        if (!apiPath) {
            // Only construct apiPath if not provided
            switch (moduleMethod) {
                // Query module endpoints
                case 'query.processQuery':
                case 'query.getQuery': // Add alias for backward compatibility
                    apiPath = '/v1/query';
                    apiMethod = 'POST';
                    // Ensure query parameter is properly named for the API
                    apiData = { 
                        query: transformedParams.query,
                        context: transformedParams.context
                    };
                    // Log the API call for debugging
                    logDebug(`[MCP Adapter] Making POST request to ${apiPath} with data:`, apiData);
                    break;
            
            // Email details endpoint
            case 'mail.getEmailDetails':
                if (!transformedParams.id) {
                    throw new Error('Email ID is required for getEmailDetails');
                }
                // Properly format the path with the ID parameter
                apiPath = `/v1/mail/${transformedParams.id}`;
                apiMethod = 'GET';
                // Log the API call for debugging
                logDebug(`[MCP Adapter] Making GET request to ${apiPath}`);
                break;
                
            // Mark email as read endpoint
            case 'mail.markAsRead':
                if (!transformedParams.id) {
                    throw new Error('Email ID is required for markAsRead');
                }
                // Properly format the path with the ID parameter
                apiPath = `/v1/mail/${transformedParams.id}/read`;
                apiMethod = 'PATCH';
                // Include isRead in the request body
                apiData = {
                    isRead: transformedParams.isRead !== false // Default to true if not explicitly set to false
                };
                // Log the API call for debugging
                logDebug(`[MCP Adapter] Making PATCH request to ${apiPath} with data:`, apiData);
                break;
            case 'mail.getInbox':
            case 'mail.readMail':
            case 'outlook mail.readMail':
                apiPath = '/v1/mail';
                apiMethod = 'GET';
                break;
            case 'mail.sendMail':
            case 'mail.sendEmail':
                apiPath = '/v1/mail/send';
                apiMethod = 'POST';
                // Transform parameters to match controller expectations
                apiData = {
                    to: transformAttendees(transformedParams.to),
                    subject: transformedParams.subject,
                    body: transformedParams.body,
                    cc: transformAttendees(transformedParams.cc),
                    bcc: transformAttendees(transformedParams.bcc)
                };
                // Log the API call for debugging
                logDebug(`[MCP Adapter] Making POST request to ${apiPath} with data:`, apiData);
                break;
            case 'mail.searchMail':
            case 'mail.searchEmails':
            case 'mail.search': // Added this alias to handle Claude's tool call
                apiPath = '/v1/mail/search';
                apiMethod = 'GET';
                // Map 'query' parameter to 'q' as expected by the controller
                if (params.query && !params.q) {
                    params.q = params.query;
                    // Remove the original query param to avoid confusion
                    delete params.query;
                }
                break;
            case 'mail.flagMail':
            case 'mail.flagEmail':
                apiPath = '/v1/mail/flag';
                apiMethod = 'POST';
                apiData = params;
                break;
            case 'mail.getAttachments':
                apiPath = '/v1/mail/attachments';
                apiMethod = 'GET';
                break;

            // Calendar module endpoints
            case 'calendar.getEvents':
            case 'calendar.getCalendar':
                apiPath = '/v1/calendar';
                apiMethod = 'GET';
                break;
            case 'calendar.createEvent':
            case 'calendar.create':
                apiPath = '/v1/calendar/events';
                apiMethod = 'POST';
                // Map of Microsoft time zones to IANA time zones
                // The server will use this mapping to convert between formats as needed
                const TIMEZONE_MAPPING = {
                    'Pacific Standard Time': 'America/Los_Angeles',
                    'Eastern Standard Time': 'America/New_York',
                    'Central Standard Time': 'America/Chicago',
                    'Mountain Standard Time': 'America/Denver',
                    'Alaskan Standard Time': 'America/Anchorage',
                    'Hawaiian Standard Time': 'Pacific/Honolulu',
                    'W. Europe Standard Time': 'Europe/Berlin',
                    'GMT Standard Time': 'Europe/London',
                    'Romance Standard Time': 'Europe/Paris',
                    'E. Europe Standard Time': 'Europe/Bucharest',
                    'Singapore Standard Time': 'Asia/Singapore',
                    'Tokyo Standard Time': 'Asia/Tokyo',
                    'China Standard Time': 'Asia/Shanghai',
                    'India Standard Time': 'Asia/Kolkata',
                    'UTC': 'UTC'
                };
                
                // For createEvent, we want to preserve the original Microsoft time zone format
                // because the Graph API expects this format in the Prefer header
                // The server's calendar-service.cjs will handle the mapping to IANA format
                
                // Make copies of start/end to avoid mutating the original
                const start = { ...transformedParams.start };
                const end = { ...transformedParams.end };
                
                // Log the original time zones for debugging
                if (start && start.timeZone) {
                    console.log(`[MCP Adapter] Original start time zone: ${start.timeZone}`);
                    // Note that we're NOT converting here - the server will handle it
                }
                
                if (end && end.timeZone) {
                    console.log(`[MCP Adapter] Original end time zone: ${end.timeZone}`);
                    // Note that we're NOT converting here - the server will handle it
                }
                
                // Pass the user's timeZone parameter if provided - this helps the server
                // determine the preferred timezone when not specified in start/end
                const timeZone = transformedParams.timeZone;
                if (timeZone) {
                    console.log(`[MCP Adapter] Using provided timeZone parameter: ${timeZone}`);
                }
                
                // Transform parameters to match the controller's expectations
                apiData = {
                    subject: transformedParams.subject,
                    start: transformDateTime(start, timeZone),
                    end: transformDateTime(end, timeZone),
                    location: transformedParams.location,
                    body: transformedParams.body,
                    isOnlineMeeting: transformedParams.isOnlineMeeting
                };
                
                // Special handling for attendees based on format
                if (transformedParams.attendees) {
                    // Handle different potential formats of attendees
                    if (Array.isArray(transformedParams.attendees)) {
                        const formattedAttendees = [];
                        
                        for (const attendee of transformedParams.attendees) {
                            // Case 1: It's already in the right format with emailAddress.address
                            if (attendee && attendee.emailAddress && attendee.emailAddress.address) {
                                formattedAttendees.push(attendee);
                            }
                            // Case 2: It's an object with email property
                            else if (attendee && attendee.email) {
                                formattedAttendees.push({
                                    emailAddress: {
                                        address: attendee.email,
                                        name: attendee.name || attendee.email.split('@')[0]
                                    },
                                    type: attendee.type || 'required'
                                });
                            }
                            // Case 3: It's a simple string (email)
                            else if (typeof attendee === 'string') {
                                formattedAttendees.push({
                                    emailAddress: {
                                        address: attendee,
                                        name: attendee.split('@')[0]
                                    },
                                    type: 'required'
                                });
                            }
                        }
                        
                        if (formattedAttendees.length > 0) {
                            apiData.attendees = formattedAttendees;
                        }
                    }
                }
                // Log the API call for debugging
                logDebug(`[MCP Adapter] Making POST request to ${apiPath} with data:`, apiData);
                break;
            case 'calendar.events': // Handle the events endpoint for fetching events
                apiPath = '/v1/calendar';  // Changed from /v1/calendar/events to /v1/calendar
                apiMethod = 'GET';
                // For GET requests, parameters go in the query string
                apiData = null;
                apiParams = {
                    limit: transformedParams.limit || 20,
                    filter: transformedParams.filter,
                    timeMin: transformedParams.timeMin,
                    timeMax: transformedParams.timeMax
                };
                
                // Log the API call for debugging
                logDebug(`[MCP Adapter] Making GET request to ${apiPath} with params:`, apiParams);
                break;
            case 'calendar.updateEvent':
            case 'calendar.update':
                // Ensure we have a valid event ID
                if (!transformedParams.id) {
                    throw new Error('Event ID is required for calendar update');
                }
                apiPath = '/v1/calendar/events/' + transformedParams.id;
                apiMethod = 'PUT';
                
                // Create an object with only the provided parameters
                // This avoids sending undefined values that could overwrite existing data
                const updateData = {};
                
                if (transformedParams.subject !== undefined) {
                    updateData.subject = transformedParams.subject;
                }
                
                if (transformedParams.start !== undefined) {
                    updateData.start = transformDateTime(transformedParams.start, transformedParams.timeZone);
                }
                
                if (transformedParams.end !== undefined) {
                    updateData.end = transformDateTime(transformedParams.end, transformedParams.timeZone);
                }
                
                if (transformedParams.attendees !== undefined) {
                    updateData.attendees = transformAttendees(transformedParams.attendees);
                }
                
                if (transformedParams.location !== undefined) {
                    updateData.location = transformedParams.location;
                }
                
                if (transformedParams.body !== undefined) {
                    updateData.body = transformedParams.body;
                }
                
                if (transformedParams.isOnlineMeeting !== undefined) {
                    updateData.isOnlineMeeting = transformedParams.isOnlineMeeting;
                }
                
                apiData = updateData;
                
                // Log the update data for debugging
                logDebug(`[MCP Adapter] Updating event ${transformedParams.id} with data:`, apiData);
                break;
            case 'calendar.getAvailability':
            case 'calendar.availability':
                apiPath = '/v1/calendar/availability';
                apiMethod = 'POST';
                
                // Ensure we have start/end dates for availability check
                if (!transformedParams.start && !transformedParams.startTime) {
                    throw new Error('Start time is required for getAvailability');
                }
                
                if (!transformedParams.end && !transformedParams.endTime) {
                    throw new Error('End time is required for getAvailability');
                }
                
                // Transform start/end to ISO string format if they're Date objects
                const startTime = typeof transformedParams.start === 'object' && transformedParams.start.dateTime 
                    ? transformedParams.start.dateTime 
                    : transformedParams.start || transformedParams.startTime;
                
                const endTime = typeof transformedParams.end === 'object' && transformedParams.end.dateTime 
                    ? transformedParams.end.dateTime 
                    : transformedParams.end || transformedParams.endTime;
                
                // Transform parameters to match the controller's expectations
                // The controller expects users and timeSlots array
                apiData = {
                    // Use users or attendees, transforming as needed
                    users: transformAttendees(transformedParams.users) || transformAttendees(transformedParams.attendees) || [],
                    // Format as timeSlots array as required by the controller
                    timeSlots: [
                        {
                            start: {
                                dateTime: startTime,
                                timeZone: transformedParams.timeZone || 'UTC'
                            },
                            end: {
                                dateTime: endTime,
                                timeZone: transformedParams.timeZone || 'UTC'
                            }
                        }
                    ]
                };
                
                // Log the transformed data for debugging
                logDebug(`[MCP Adapter] Transformed availability data:`, apiData);
                break;
            case 'calendar.acceptEvent':
                apiPath = `/v1/calendar/events/${params.eventId}/accept`;
                apiMethod = 'POST';
                apiData = params.comment ? { comment: params.comment } : {};
                break;
            case 'calendar.tentativelyAcceptEvent':
                apiPath = `/v1/calendar/events/${params.eventId}/tentativelyAccept`;
                apiMethod = 'POST';
                apiData = params.comment ? { comment: params.comment } : {};
                break;
            case 'calendar.declineEvent':
                apiPath = `/v1/calendar/events/${params.eventId}/decline`;
                apiMethod = 'POST';
                apiData = params.comment ? { comment: params.comment } : {};
                break;
            case 'calendar.cancelEvent':
                // Handle both eventId and id parameter names
                if (!transformedParams.eventId && !transformedParams.id) {
                    throw new Error('Event ID is required for cancelEvent (either eventId or id parameter)');
                }
                
                const cancelEventId = transformedParams.eventId || transformedParams.id;
                apiPath = `/v1/calendar/events/${cancelEventId}/cancel`;
                apiMethod = 'POST';
                apiData = transformedParams.comment ? { comment: transformedParams.comment } : {};
                
                // Log the cancel request
                logDebug(`[MCP Adapter] Cancelling event ${cancelEventId}`);
                break;
            case 'calendar.findMeetingTimes':
            case 'calendar.findtimes': // Add this case to handle the findtimes endpoint
                apiPath = '/v1/calendar/findMeetingTimes';
                apiMethod = 'POST';
                // Transform parameters to match what the calendar service expects
                
                // Extract time constraints from different possible input formats
                let timeConstraints = transformedParams.timeConstraints;
                if (!timeConstraints && (transformedParams.startTime || transformedParams.start)) {
                    timeConstraints = {
                        startTime: transformedParams.startTime || transformedParams.start,
                        endTime: transformedParams.endTime || transformedParams.end,
                        timeZone: transformedParams.timeZone || 'UTC'
                    };
                }
                
                apiData = {
                    // Transform attendees to array format
                    attendees: transformAttendees(transformedParams.attendees) || [],
                    // Time constraints
                    timeConstraint: {
                        start: timeConstraints?.startTime || timeConstraints?.start,
                        end: timeConstraints?.endTime || timeConstraints?.end,
                        timeZone: timeConstraints?.timeZone || transformedParams.timeZone || 'UTC'
                    },
                    // Duration in minutes
                    meetingDuration: transformedParams.meetingDuration || transformedParams.duration || 60,
                    // Additional parameters
                    maxCandidates: transformedParams.maxCandidates || 10,
                    minimumAttendeePercentage: transformedParams.minimumAttendeePercentage || 100
                };
                
                // Log the transformed parameters for debugging
                logDebug(`[MCP Adapter] Transformed findMeetingTimes parameters:`, apiData);
                break;
            case 'calendar.scheduleMeeting':
            case 'calendar.schedule': // Add alias for backward compatibility
                apiPath = '/v1/calendar/events'; // Map to the same endpoint as createEvent
                apiMethod = 'POST';
                
                // Extract start and end time information - prioritize preferredTimes if available
                let meetingStartTime, meetingEndTime;
                
                if (transformedParams.preferredTimes && transformedParams.preferredTimes.length > 0) {
                    meetingStartTime = transformedParams.preferredTimes[0].start;
                    meetingEndTime = transformedParams.preferredTimes[0].end;
                    console.log(`[MCP Adapter scheduleMeeting] Using preferredTimes: ${JSON.stringify(meetingStartTime)} to ${JSON.stringify(meetingEndTime)}`);
                } else {
                    // Try various parameter combinations to extract start/end times
                    if (transformedParams.start) {
                        meetingStartTime = transformedParams.start;
                    } else if (transformedParams.startDateTime) {
                        meetingStartTime = { 
                            dateTime: transformedParams.startDateTime, 
                            timeZone: transformedParams.timeZone || 'Pacific Standard Time' 
                        };
                    }
                    
                    if (transformedParams.end) {
                        meetingEndTime = transformedParams.end;
                    } else if (transformedParams.endDateTime) {
                        meetingEndTime = { 
                            dateTime: transformedParams.endDateTime, 
                            timeZone: transformedParams.timeZone || 'Pacific Standard Time' 
                        };
                    }
                    
                    console.log(`[MCP Adapter scheduleMeeting] Using direct parameters: ${JSON.stringify(meetingStartTime)} to ${JSON.stringify(meetingEndTime)}`);
                }
                
                // Log timezone information for debugging
                if (meetingStartTime && meetingStartTime.timeZone) {
                    console.log(`[MCP Adapter scheduleMeeting] Start time zone: ${meetingStartTime.timeZone}`);
                }
                
                if (meetingEndTime && meetingEndTime.timeZone) {
                    console.log(`[MCP Adapter scheduleMeeting] End time zone: ${meetingEndTime.timeZone}`);
                }
                
                if (transformedParams.timeZone) {
                    console.log(`[MCP Adapter scheduleMeeting] Default time zone: ${transformedParams.timeZone}`);
                }
                
                // Transform parameters to match what the calendar controller expects
                apiData = {
                    // Required parameters
                    subject: transformedParams.subject,
                    attendees: transformAttendees(transformedParams.attendees) || [],
                    // Use the extracted start and end times
                    start: meetingStartTime ? transformDateTime(meetingStartTime, transformedParams.timeZone) : undefined,
                    end: meetingEndTime ? transformDateTime(meetingEndTime, transformedParams.timeZone) : undefined,
                    // Optional parameters
                    location: transformedParams.location,
                    body: transformedParams.body,
                    isOnlineMeeting: transformedParams.isOnlineMeeting
                };
                // Log the API call for debugging
                logDebug(`[MCP Adapter] Making POST request to ${apiPath} with data:`, apiData);
                break;
            case 'calendar.getRooms':
                apiPath = '/v1/calendar/rooms';
                apiMethod = 'GET';
                break;
            case 'calendar.getCalendars':
                apiPath = '/v1/calendar/calendars';
                apiMethod = 'GET';
                break;
            case 'calendar.addAttachment':
                apiPath = `/v1/calendar/events/${params.eventId}/attachments`;
                apiMethod = 'POST';
                apiData = params.attachment;
                break;
            case 'calendar.removeAttachment':
                apiPath = `/v1/calendar/events/${params.eventId}/attachments/${params.attachmentId}`;
                apiMethod = 'DELETE';
                break;

            // Files module endpoints
            case 'files.listFiles':
                apiPath = '/v1/files';
                apiMethod = 'GET';
                break;
            case 'files.searchFiles':
                apiPath = '/v1/files/search';
                apiMethod = 'GET';
                break;
            case 'files.downloadFile':
                apiPath = '/v1/files/download';
                apiMethod = 'GET';
                break;
            case 'files.uploadFile':
                apiPath = '/v1/files/upload';
                apiMethod = 'POST';
                apiData = params;
                break;
            case 'files.getFileMetadata':
                apiPath = '/v1/files/metadata';
                apiMethod = 'GET';
                break;
            case 'files.createSharingLink':
                apiPath = '/v1/files/share';
                apiMethod = 'POST';
                apiData = params;
                break;
            case 'files.getSharingLinks':
                apiPath = '/v1/files/sharing';
                apiMethod = 'GET';
                break;
            case 'files.removeSharingPermission':
                apiPath = '/v1/files/sharing/remove';
                apiMethod = 'POST';
                apiData = params;
                break;
            case 'files.getFileContent':
                apiPath = '/v1/files/content';
                apiMethod = 'GET';
                break;
            case 'files.setFileContent':
                apiPath = '/v1/files/content';
                apiMethod = 'POST';
                apiData = params;
                break;
            case 'files.updateFileContent':
                apiPath = '/v1/files/content/update';
                apiMethod = 'POST';
                apiData = params;
                break;

            // People module endpoints
            case 'people.getRelevantPeople':
                apiPath = '/v1/people';
                apiMethod = 'GET';
                // Map any limit parameter correctly
                if (params.limit) {
                    params.limit = parseInt(params.limit, 10);
                }
                break;
            case 'people.searchPeople':
            case 'people.search':
                apiPath = '/v1/people/search';
                apiMethod = 'GET';
                // Make sure query parameter is preserved
                if (!params.query && params.q) {
                    params.query = params.q;
                    // Remove the q param to avoid confusion
                    delete params.q;
                }
                break;
            case 'people.findPeople':
            case 'people.find':
                apiPath = '/v1/people/find';
                apiMethod = 'GET';
                // Make sure query parameter is preserved
                if (!params.query && params.q) {
                    params.query = params.q;
                    // Remove the q param to avoid confusion
                    delete params.q;
                }
                // Ensure limit is parsed as integer
                if (params.limit) {
                    params.limit = parseInt(params.limit, 10);
                }
                break;
            case 'people.getPersonById':
                apiPath = `/v1/people/${params.id}`;
                apiMethod = 'GET';
                break;

            // System endpoints
            case 'system.getToolDefinitions':
                apiPath = '/tools';
                apiMethod = 'GET';
                break;
            case 'system.getManifest':
                apiPath = '/tools';  // Same as getToolDefinitions but we'll transform the response
                apiMethod = 'GET';
                break;
            case 'system.getResources':
                // Return empty resources list as this isn't implemented yet
                return { resources: [] };
            case 'system.getPrompts':
                // Return empty prompts list as this isn't implemented yet
                return { prompts: [] };
            default:
                throw new Error(`Unknown API endpoint for ${moduleName}.${methodName}`);
        }

        // For GET requests with params, add them as query parameters
        if (apiMethod === 'GET' && Object.keys(params).length > 0) {
            const queryParams = new URLSearchParams();
            for (const [key, value] of Object.entries(params)) {
                // Special handling for complex objects and arrays to prevent [object Object] in URLs
                if (typeof value === 'object' && value !== null) {
                    continue; // Skip adding complex objects to query params
                } else {
                    queryParams.append(key, value);
                }
            }
            
            if (queryParams.toString()) {
                apiPath += `?${queryParams.toString()}`;
            }
        }

        logDebug(`[MCP Adapter] Executing ${moduleName}.${methodName} via API: ${apiMethod} ${apiPath}`);
        const result = await callApi(apiMethod, apiPath, apiData);

        // Special case for system.getManifest to transform tools list to manifest format
        if (`${moduleName}.${methodName}` === 'system.getManifest' && result && result.tools) {
            return {
                protocolVersion: params.protocolVersion || "2024-11-05",
                capabilities: {
                    toolInvocation: true,
                    manifest: true
                },
                serverInfo: {
                    name: "Microsoft 365 MCP Gateway",
                    version: "1.0.0"
                }
            };
        }

        // TODO: [Streaming] Handle streaming responses if API supports it (e.g., for file downloads) (MEDIUM)

        return result;
    } catch (error) {
        logDebug(`[MCP Adapter] Error executing ${moduleName}.${methodName}:`, error.message);
        if (error.message.includes('authentication') || error.message.includes('unauthorized') || error.message.includes('401')) {
            return { 
                error: 'Authentication required. Please log in via the web UI.',
                errorType: 'auth_required'
            };
        }
        return { 
            error: `Error executing ${moduleName}.${methodName}: ${error.message}`,
            errorType: 'module_error'
        };
    }
}

// Helper: Map MCP tool calls to module methods
async function handleToolCall(toolName, toolArgs) {
    try {
        // Make sure adapter is initialized
        if (!adapterState.initialized) {
            await initializeAdapter();
        }

        // Update last activity timestamp
        adapterState.lastActivity = Date.now();
        
        // Get tool definitions from the API
        const toolsResponse = await callApi('GET', '/tools');
        if (!toolsResponse || !Array.isArray(toolsResponse.tools)) {
            throw new Error('Failed to retrieve tool definitions from API');
        }
        
        // Find the tool definition
        const toolDef = toolsResponse.tools.find(tool => tool.name === toolName);
        if (!toolDef) {
            throw new Error(`Unknown tool: ${toolName}`);
        }
        
        logDebug(`[MCP Adapter] Found tool definition for ${toolName}:`, toolDef);
        
        // Extract module and method from endpoint
        // Example: /api/v1/mail/send -> mail.sendEmail
        const path = toolDef.endpoint.replace('/api', '');
        const apiPath = path; // Store the full API path for executeModuleMethod
        
        // Extract the module name and method from the path
        // Remove the /v1/ prefix to get the module path
        const modulePath = path.replace(/^/v1//, '');
        const parts = modulePath.split('/');
        
        if (parts.length === 0) {
            throw new Error(`Invalid endpoint path: ${path}`);
        }
        
        const moduleName = parts[0];
        
        // Special case for calendar.create which can be called as createEvent
        if (toolName === 'createEvent') {
            logDebug(`[MCP Adapter] Using direct mapping for createEvent -> calendar.create`);
            return await executeModuleMethod('calendar', 'create', toolArgs, apiPath, toolDef.method);
        }
        
        // Special case mappings for root endpoints
        const methodMappings = {
            'mail': { '': 'getInbox' },
            'calendar': { '': 'getEvents' },
            'files': { '': 'listFiles' },
            'people': { '': 'getRelevantPeople' }
        };
        
        let methodName;
        if (parts.length === 1 && methodMappings[moduleName] && methodMappings[moduleName]['']) {
            // Root endpoint like /v1/mail -> mail.getInbox
            methodName = methodMappings[moduleName][''];
        } else if (parts.length > 1) {
            // Endpoint with method like /v1/mail/send -> mail.sendEmail
            methodName = parts[1];
            
            // Handle special case mappings for specific endpoints
            const specialMethodMappings = {
                'mail': {
                    'send': 'sendEmail',
                    'search': 'searchEmails',
                    'flag': 'flagEmail'
                },
                'calendar': {
                    'events': 'create', // For POST to /v1/calendar/events
                    'findMeetingTimes': 'findMeetingTimes'
                },
                'people': {
                    'search': 'searchPeople',
                    'find': 'findPeople'
                }
            };
            
            if (specialMethodMappings[moduleName] && specialMethodMappings[moduleName][methodName]) {
                methodName = specialMethodMappings[moduleName][methodName];
            }
        } else {
            throw new Error(`Could not determine method name from endpoint: ${path}`);
        }
        
        logDebug(`[MCP Adapter] Mapped ${toolName} to ${moduleName}.${methodName}`);
        
        // Special case for calendar events with timeframe
        if (moduleName === 'calendar' && methodName === 'getEvents' && toolArgs.timeframe) {
            // Process date ranges for calendar
            const timeframe = toolArgs.timeframe;
            let start, end;
            
            const today = new Date();
            const todayStr = today.toISOString().split('T')[0];
            
            switch (timeframe) {
                case 'today':
                    start = todayStr;
                    end = todayStr;
                    break;
                case 'week':
                    // Start of current week (Sunday)
                    const startOfWeek = new Date(today);
                    startOfWeek.setDate(today.getDate() - today.getDay());
                    start = startOfWeek.toISOString().split('T')[0];
                    
                    // End of current week (Saturday)
                    const endOfWeek = new Date(today);
                    endOfWeek.setDate(today.getDate() + (6 - today.getDay()));
                    end = endOfWeek.toISOString().split('T')[0];
                    break;
                case 'month':
                    // Start of current month
                    start = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-01`;
                    
                    // End of current month
                    const lastDay = new Date(today.getFullYear(), today.getMonth() + 1, 0);
                    end = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(lastDay.getDate()).padStart(2, '0')}`;
                    break;
                default:
                    // Default to today if timeframe is not recognized
                    start = todayStr;
                    end = todayStr;
            }
            
            logDebug(`[MCP Adapter] Calendar request with date range: ${start} to ${end}`);
            
            // Add date range to the arguments
            toolArgs = {
                ...toolArgs,
                start,
                end
            };
        }
        
        // Execute the module method with the API path and method from the tool definition
        return await executeModuleMethod(moduleName, methodName, toolArgs, apiPath, toolDef.method);
    } catch (error) {
        logDebug(`[MCP Adapter] Error handling tool call ${toolName}:`, error.message);
        return { 
            error: `Error handling tool call: ${error.message}`,
            errorType: 'tool_error'
        };
    }
}

// Helper: handle incoming JSON-RPC requests
async function handleRequest(msg) {
    const { id, method, params } = msg;

    // Debug: log every request to stderr and file
    logDebug(`[MCP Adapter] Received: ${method}`, params);
    logToFile('Received:', method, params);

    try {
        let result;

        // Handle standard MCP methods
        switch (method) {
            case 'initialize': {
                // Standard MCP handshake with protocolVersion, capabilities
                result = {
                    protocolVersion: (params && params.protocolVersion) ? params.protocolVersion : "2024-11-05",
                    capabilities: {
                        toolInvocation: true,
                        manifest: true
                    },
                    serverInfo: {
                        name: "MCP Microsoft 365 Gateway",
                        version: "1.0.0"
                    }
                };
                sendResponse(id, result, null);
                logToFile('Responded:', method, { id, result });
                logDebug("[MCP Adapter] Responded to initialize with protocolVersion:", result.protocolVersion);
                return;
            }
            case 'tools/call': {
                if (!params || !params.name) {
                    sendResponse(id, null, { code: -32602, message: 'Missing tool name in params' });
                    return;
                }

                const toolName = params.name;
                const toolArgs = params.arguments || {};
                logDebug(`[MCP Adapter] Calling tool: ${toolName} with args:`, toolArgs);

                try {
                    // Use the handleToolCall function to process the tool call
                    const toolResult = await handleToolCall(toolName, toolArgs);

                    if (toolResult && toolResult.error) {
                        logDebug(`[MCP Adapter] Tool error (${toolName}):`, toolResult.error);
                        sendResponse(id, null, { code: -32603, message: `Tool error: ${toolResult.error}` });
                        return;
                    }

                    // Format the result according to MCP spec
                    const formattedResult = {
                        content: [
                            {
                                type: "text",
                                text: JSON.stringify(toolResult, null, 2)
                            }
                        ],
                        isError: false
                    };

                    // Success response
                    sendResponse(id, formattedResult, null);
                    logDebug(`[MCP Adapter] Tool ${toolName} succeeded:`, JSON.stringify(toolResult).substring(0, 100) + '...');
                    return;
                } catch (err) {
                    logDebug(`[MCP Adapter] Tool error (${toolName}):`, err);
                    sendResponse(id, null, { code: -32603, message: `Tool error: ${err.message}` });
                    return;
                }
                break;
            }
            case 'tools/list':
                // Get the tools list from the API
                try {
                    logDebug('[MCP Adapter] Getting tools list from API');
                    const toolsResult = await callApi('GET', '/tools');

                    if (!toolsResult || !toolsResult.tools) {
                        logDebug('[MCP Adapter] API returned invalid tools list');
                        // Fallback to empty list if API fails
                        result = {
                            protocolVersion: (params && params.protocolVersion) ? params.protocolVersion : "2024-11-05",
                            tools: []
                        };
                    } else {
                        // Convert API tools format to MCP format
                        const mcpTools = toolsResult.tools.map(tool => ({
                            name: tool.name,
                            description: tool.description,
                            inputSchema: {
                                type: 'object',
                                properties: Object.entries(tool.parameters || {}).reduce((acc, [key, value]) => {
                                    acc[key] = {
                                        type: value.type || 'string',
                                        description: value.description || ''
                                    };
                                    return acc;
                                }, {}),
                                required: Object.entries(tool.parameters || {})
                                    .filter(([_, value]) => !value.optional)
                                    .map(([key, _]) => key)
                            }
                        }));

                        result = {
                            protocolVersion: (params && params.protocolVersion) ? params.protocolVersion : "2024-11-05",
                            tools: mcpTools
                        };
                    }
                } catch (error) {
                    logDebug('[MCP Adapter] Error getting tools list from API:', error.message);
                    // Fallback to empty list if API fails
                    result = {
                        protocolVersion: (params && params.protocolVersion) ? params.protocolVersion : "2024-11-05",
                        tools: []
                    };
                }
                sendResponse(id, result, null);
                logToFile('Responded:', method, { id, result });
                logDebug("[MCP Adapter] Responded to tools/list");
                return;
            case 'getManifest':
                // Legacy method - same as tools/list for compatibility
                // Create a standard MCP manifest
                result = {
                    protocolVersion: (params && params.protocolVersion) ? params.protocolVersion : "2024-11-05",
                    capabilities: {
                        toolInvocation: true,
                        manifest: true
                    },
                    serverInfo: {
                        name: "Microsoft 365 MCP Gateway",
                        version: "1.0.0"
                    }
                };
                sendResponse(id, result, null);
                logToFile('Responded:', method, { id, result });
                logDebug("[MCP Adapter] Responded to getManifest");
                return;
            case 'resources/list':
                // Return empty resources list (not implemented yet)
                logDebug('[MCP Adapter] Returning empty resources list');
                result = { resources: [] };
                sendResponse(id, result, null);
                logToFile('Responded:', method, { id, result });
                logDebug("[MCP Adapter] Responded to resources/list");
                return;
            case 'prompts/list':
                // Return empty prompts list (not implemented yet)
                logDebug('[MCP Adapter] Returning empty prompts list');
                result = { prompts: [] };
                sendResponse(id, result, null);
                logToFile('Responded:', method, { id, result });
                logDebug("[MCP Adapter] Responded to prompts/list");
                return;
            default:
                logDebug(`[MCP Adapter] Unknown method: ${method}`);
                sendResponse(id, null, { code: -32601, message: `Method not found: ${method}` });
                return;
        }
    } catch (err) {
        logDebug(`[MCP Adapter] Error handling ${method}:`, err);
        sendResponse(id, null, { code: -32603, message: `Internal error: ${err.message}` });
    }
}

// Helper: handle core requests (manifest, listResources)
async function _handleCoreRequest(coreMethodName, requestId, coreParams = {}) {
    logDebug(`[MCP Adapter] Handling core request: ${coreMethodName}`);
    try {
        const hasAccess = await checkModuleAccess();
        if (!hasAccess) {
            sendResponse(requestId, null, createJsonRpcError(-32001, 'Access Denied', 'Backend or modules unavailable.'));
            return;
        }
        const result = await executeModuleMethod('core', coreMethodName, coreParams);
        sendResponse(requestId, result);
    } catch (error) { 
        logDebug(`[MCP Adapter] Error handling ${coreMethodName}:`, error);
        sendResponse(requestId, null, createJsonRpcError(-32603, 'Internal Error', `Error handling ${coreMethodName}: ${error.message}`));
    }
}

// Initialize: check backend API availability
async function initialize() {
    // Allow skipping initialization for specific test environments
    if (process.env.MCP_SKIP_INIT === 'true') {
        logDebug('[MCP Adapter] Skipping initialization due to MCP_SKIP_INIT flag.');
        adapterState.initialized = true; // Mark as initialized to avoid re-triggering
        adapterState.backendAvailable = true; // Assume available for tests
        return Promise.resolve(true);
    }

    logDebug('[MCP Adapter] Initializing (API isolation approach)...');
    const ok = await initializeAdapter();
    if (!ok) {
        logDebug('[MCP Adapter] Initialization failed: Backend API not available.');
    } else {
        logDebug('[MCP Adapter] Initialization successful: Backend API available.');
    }
    return Promise.resolve(ok);
}

// Graceful shutdown
async function shutdown() {
    logDebug('[MCP Adapter] Shutting down...');
    if (healthCheckInterval) {
        clearInterval(healthCheckInterval);
        healthCheckInterval = null;
        logDebug('[MCP Adapter] Health check interval cleared.');
    }
    // TODO: [Cleanup] Add any other necessary cleanup (e.g., close connections) (LOW)
}

// Main: read stdin line by line, handle JSON-RPC
const rl = readline.createInterface({ input: process.stdin });
rl.on('line', (line) => {
    try {
        const msg = JSON.parse(line);
        const { id, method, params } = msg;
        // MCP PATCH: Ignore JSON-RPC notifications (method present, id undefined)
        if (method && typeof id === 'undefined') {
            logToFile('Received', method, { params });
            logDebug(`[MCP Adapter] Received notification: ${method} ${JSON.stringify(params)}`);
            // Do not respond to notifications, per JSON-RPC spec
            return;
        }
        // Normal request: handle as before
        handleRequest(msg);
    } catch (err) {
        logDebug('[MCP Adapter] Invalid JSON-RPC:', line, err);
    }
});

// Log if stdin closes unexpectedly
rl.on('close', () => {
    logDebug('[MCP Adapter] Stdin closed. Exiting.');
    process.exit(0);
});

// Handle process signals for clean shutdown
process.on('SIGINT', () => {
    logDebug('[MCP Adapter] Received SIGINT. Exiting.');
    shutdown().then(() => process.exit(0));
});

process.on('SIGTERM', () => {
    logDebug('[MCP Adapter] Received SIGTERM. Exiting.');
    shutdown().then(() => process.exit(0));
});

// Run initialization (proxy approach)
initialize();
